<!DOCTYPE html><html><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><html lang="en-US"></html><title>mee42.dev | Blog</title><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/17e1c257e36565454180.css" as="style"/><link rel="stylesheet" href="/_next/static/css/17e1c257e36565454180.css"/><link rel="preload" href="/_next/static/css/d3143060ca26b3eec8b4.css" as="style"/><link rel="stylesheet" href="/_next/static/css/d3143060ca26b3eec8b4.css"/><link rel="preload" href="/_next/static/chunks/main-5111d87fab9b5370cc9a.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-488dc228921f1fdbc0e7.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.1b5fae6dde8a26be77ac.js" as="script"/><link rel="preload" href="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.385dc8404ef76b6a4b4e.js" as="script"/><link rel="preload" href="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.93fe777673a5651520d9.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-93e30f94c05dd8c9a648.js" as="script"/><link rel="preload" href="/_next/static/chunks/1a2af845c0b0daf3d71ab5908136823678b656af.a06c409320be9f87330b.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog-9544ab5f384daa1dc7a6.js" as="script"/></head><body><div id="__next"><div><header class="header_header__2q1wF"><a href="/" class="header_mainButton__3_bcA"><code>mee42.dev</code></a><div><div class="header_withGrow__2qx96"></div><a href="/">Home</a><div class="header_withGrow__2qx96"></div><div class="header_bottomBorder__3FSRX"></div></div><div><div class="header_withGrow__2qx96"></div><a href="/projects">Projects</a><div class="header_withGrow__2qx96"></div><div class="header_bottomBorder__3FSRX"></div></div><div><div class="header_withGrow__2qx96"></div><a href="/blog">Blog</a><div class="header_withGrow__2qx96"></div><div class="header_bottomBorder__3FSRX"></div></div><div><div class="header_withGrow__2qx96"></div><a href="https://github.com/mee42/">Github</a><div class="header_withGrow__2qx96"></div><div class="header_bottomBorder__3FSRX"></div></div></header><div class="blog_body__1OHPr"><h3 class="blog_title__22wdS">Blog</h3><ul id="HELO" class="blog_blogPostList__WjHpl"><li><a href="/blog/1#first-post-on-mee42-dot-dev"><span class="blog_blogPostDate__287QF">2020-08-10</span><span class="blog_blogPostTitle__19-gA">First Blog Post!</span></a></li><li><a href="/blog/5#advent-of-code-day-1"><span class="blog_blogPostDate__287QF">2020-12-01</span><span class="blog_blogPostTitle__19-gA">Advent of code, Day 1!</span></a></li><li><a href="/blog/6#advent-of-code-day-2"><span class="blog_blogPostDate__287QF">2020-12-02</span><span class="blog_blogPostTitle__19-gA">Advent of code, Day 2</span></a></li><li><a href="/blog/4#optimization-thoughts"><span class="blog_blogPostDate__287QF">2020-10-21</span><span class="blog_blogPostTitle__19-gA">Some thoughts on optimization</span></a></li></ul></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blogPosts":[{"id":1,"title":"First Blog Post!","desc":"This is the first blog post on this site, and where I'll be talking about random things, from programming to robotics","tags":["meta","testing"],"url":"first-post-on-mee42-dot-dev","date":"2020-08-10","content":"here is some content! content is good! I like content.\n\nthere will be many newlines in the content\n```\nlets test some markdown features\n```\n# h1\n## h2\n### h3\n#### h4\n##### h5\n###### h6\n\n*italics*\n\n**bold**\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\nhere is `some code exceprts` which should be in monospace and `markdown`.\n\n[link to an example website](https://example.com)\n\n[link back to the main blog page](/blog)\n\n\n- a list\n- of several\n- `styled` unordered elements\n\n1. a list of\n1. ordered elements\n1. however the order is automatically generated\n\n| a table | vibe |\n| ------- | ---- |\n| HTML    | low vibe |\n| markdown | high vibe |\n\n\u003e quoting someone\n\u003e is nice\n\n\n```js\nvar React = require(\"react\");\nvar Markdown = require(\"react-markdown\");\n```"},{"id":5,"title":"Advent of code, Day 1!","desc":"A short writeup for the first day of Advent of Code!","tags":["algorithm","aoc"],"url":"advent-of-code-day-1","date":"2020-12-01","content":"Advent of code is a month-long (25 days, really) coding challenge that tens of thousands of developers partake in every year. It's not a competition, unless you want to compete at midnight with everyone else to solve it as fast as possible, which is not most people.\n\n\nI'm Carson, and in this post I'm going to be going over the basics of the competition, and then getting into the day 1 challenge, which was released today (December 1st) at midnight EST.\n\n## What is Advent of Code\n\nAdvent of Code (AOC), like I said before, is a 25 day programming challenge.\nEach day there is a 2-part problem released. \nThe unofficial \"goal\" of many programmers is to finish the challenge within that day, but there is no time limit! The 2016 challenges are still open, if you can't get enough of the 2020 season.\n\nWho does Advent of Code? Anyone who wants to! \nYou can read some general information [on the about page](https://adventofcode.com/2020/about).\nYou don't need to have 10 years of experience in development work.\n\n*I'll be quoting the AOC website using quote blocks throughout these blog posts*\n\n\u003e You don't need a computer science background to participate - just a little programming knowledge and some problem solving skills will get you pretty far.\n\nI run my school's Computer Science club, and we have many members who don't have much formal education in CS - but still can tackle some of these problems, and learn lots about Computer Science.\n\n### So... Are the problems hard?\n\nYes and no. The first couple are easier, the last couple will take work. \nDoing 5 is much better than doing 0 - so don't worry about not being up to the later days.\n\n## Day 1\n\nSo, let's dive into a question! I'm going to read through the day 1 page, and talk more about AOC. There won't be any spoilers until you reach the warning.\n\n--------\n\n\u003e The tropical island has its own currency and is entirely cash-only. The gold coins used there have a little picture of a starfish; the locals just call them stars. None of the currency exchanges seem to have heard of them, but somehow, you'll need to find fifty of these coins by the time you arrive so you can pay the deposit on your room.\n\u003e\n\u003e \n\u003e To save your vacation, you need to get all fifty stars by December 25th.\n\nAdvent of Code has some story, which makes reading each of the challenges easier and more enjoyable.\n\n\u003e Collect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!\n\nThe goal is to get 50 stars, which means finishing both part 1 and part 2 of all 25 days\nThis may seem like a lot, but it's only 2 a day - definitely doable, if you have the time.\n\n\u003e Before you leave, the Elves in accounting just need you to fix your **expense report** (your puzzle input); apparently, something isn't quite adding up.\n\nNow, we're getting to the *challenge*.\nThere's a couple key elements that are the same for all challenges.\n\nAll challenges have a *puzzle input*. This is a plaintext file that you can find with a link on the page, and is personalized to you in specific (so you can't easily cheat). \nIt's important to download this file and read it into your program to start off the challenge.\n\n\u003e Specifically, they need you to find the two entries that sum to 2020 and then multiply those two numbers together.\n\nOnce we get to this line, we need to start thinking about solving the challenge.\nWe can see that the input is a list (or set, as order is irrelevant) of numbers. Generally the numbers will fit within a 32-bit integer, unless otherwise specified, so you can use the normal int type in your programming language of choice. The output is the product of two numbers, so the output is also a number. This is something shared between all challenges - the solution is a number.\n\n\u003e For example, suppose your expense report contained the following:\n\u003e ```\n\u003e 1721\n\u003e 979\n\u003e 366\n\u003e 299\n\u003e 675\n\u003e 1456\n\u003e ```\n\nThis is a *sample input* to your program. They give you the answer, as well as an explanation\n\n\u003e In this list, the two entries that sum to `2020` are `1721` and `299`. Multiplying them together produces `1721 * 299 = 514579`, so the correct answer is `514579`. \n\nYou'll need to test your program on this sample input to verify that it works before trying it on the puzzle input given to you, as it says on the next line\n\n\u003e Of course, your expense report is much larger. Find the two entries that sum to 2020; what do you get if you multiply them together?\n\nSo, that's the challenge. Go at it. Come back once you're done.\n\nYou don't get access to part 2 until you finish part 1, so you need to finish part 1 first.\n\n---\n\n## Advent of Code Day 1 Writeup\n\n*note - if you have not completed both parts of the day 1 challenge, you should not read on, that's cheating*\n\n\u003e Specifically, they need you to **find the two entries that sum to 2020** and then multiply those two numbers together.\n\nMy first thought is that we need to find two entries. A pair of entries. \nIf you look at the example input, these entries don't need to be next to each other in the input - \nit just needs to be any two numbers.\n\nSo, we'll try and iterate through all possible pairs of entries. We can do this with a couple loops.\n\n*As a side note, I'll be doing these writeups in a variety of languages. \nI will try and make it readable without knowledge of those language*\n\n```kt\nval input = inputLines(1) // this function gets the puzzle input\nfor(val firstEntry : input) { // iterate over each element in input\n    for(val secondEntry : input) { //  iterate over again, for each value in input\n        // ... code\n    }\n}\n```\nInside the two loops, we'll need to check to see if it is a valid pair of entries. To refer back to the page\n\n\u003e Of course, your expense report is much larger. Find the two entries that sum to 2020; what do you get if you multiply them together?\n\nWe need to see if the sum is 2020, and if it is, return the product.\n```kt\nval sum = firstEntry + secondEntry;\nif(sum == 2020) {\n    println(\"The answer is :\" + (firstEntry * secondEntry))\n    return // avoid doing unnecessary computation after we find the answer\n}\n```\n\nAnd... this works! This problem was pretty simple.\n\n*However...* Before we move on to part 2, I want to touch briefly on computation time.\n\nWith the two nested loops, this solution will run in `O(n^2)`. \nFor those not familiar with big-O, all that means is that if the input (`n`) is `20`, then the program will run in `400c`, where `c` is an unknown constant. The important part is how this scales - if `n` increases by `5`, becoming `n = 25`, then the running time becomes `625`, which is quite a bit more than the initial `400`. If we have a `O(n^2)` solution, there is a maximum value of `n` for which it will take longer than acceptable to run. A `O(n)` solution can have a much much higher value for `n` (in theory) before it takes too long, and a `O(n^2)` solution will have a very low limit on `n` because of how fast it grows.\n\nSo, we want to try and have an `O(n)` solution. That means we can only have one loop:\n```kt\nfor(val firstEntry : inputs) {\n    // ... code\n}\n```\nNow, one fun thing we can use is that, for a valid solution, `firstEntry + secondEntry = 2020`.\nThis means we can calculate a \"possibly valid `secondEntry`\", that may or may not be in the input list, with subtraction\n```kt\nfor(val firstEntry : inputs) {\n    val possibleSecondEntry = 2020 - firstEntry\n    // now we need to see if possibleSecondEntry exist in the input\n    for(val checkingSecondEntry : inputs) { // line 4\n        if(possibleSecondEntry == possibleSecondEntry) {\n            println(\"Got result! \" + (firstEntry * possibleSecondEntry))\n            return\n        }\n    } // line 9\n}\n```\nNow, this is actually still on the order of `O(n^2)`. We still have two loops. We haven't gained anything.\n\nIf you look between line 4 and 9, you can see there's an exact implementation of a `List\u003cT\u003e#contains(T)` function.\nSeeing if an element is contained within a list is an inherently `O(n)` operation, as you need to iterate over each element.\n\n\nThere is, however, another data structure that has a `O(1)` contains function.\n\n#### Introducing, HashSets\n\nSets are like lists, but do *not* have order, nor do they have duplicate elements. \nWithout the responsibility of maintaining order, sets can have `O(1)` insertion, deletion, query functions - and, important to us, they can do `contains` in just `O(1)`.\n\n\nLet's rewrite our code to use a HashSet.\n\n```kt\nval inputSet = inputs.toHashSet() // convert to a hash set\nfor(val firstEntry : inputSet) {\n    val possibleSecondEntry = 2020 - firstEntry\n    if(inputSet.contains(possibleSecondEntry)) { // O(1)\n        // the input does contain that possible second entry!\n        println(\"Got the result: \" + (firstEntry * possibleSecondEntry))\n        return \n    }\n}\n```\n\nThis also works, and it'll work with much larger inputs than the above `O(n^2)` solution (though it's irrelevant for our `n = 200` puzzle input).\n\n\n## Part 2\n\n\u003e In your expense report, what is the product of the three entries that sum to 2020?\n\nWe want to do this the same way as the other one - generate all possible combinations of 3 entries, and then verify that they are all part of the input (if we don't know already), and see which work. \n\nNow, given just `firstEntry`, we can't calculate `possibleSecondEntry` and `possibleThirdEntry`. We need to check a valid second entry in order to calculate the third entry. This means two loops\n```kt\nfor(val firstEntry : inputSet) {\n    for(val secondEntry : inputSet) {\n        // By here, we can calculate possibleThirdEntry, and test it\n        val possibleThirdEntry = 2020 - firstEntry - secondEntry\n        if(inputSet.contains(possibleThirdEntry)) {\n            println(\"finally, got it\" + (firstEntry * secondEntry * possibleThirdEntry)) // multiply them all\n            return\n        }\n    }\n}\n```\n\nNow, this is `O(n^2)`. It is actually an *unsolved challenge* in computer science to preform this as fast as possible. You can read about it more [on the 3SUM Wikipedia page](https://en.wikipedia.org/wiki/3SUM), if you want to waste any more of your afternoon on Advent of Code.\n\nThat's about it, though. If you have any comments on this page, you can reach me at `arson#5069`. \n\n\n\n\nHere's my final code, as well as [a link to the GitHub repository](https://github.com/Mee42/aoc-2020/blob/master/src/main/kotlin/day1/Day1.kt)\n```kt\nfun main1(): Int {\n    val numberSet = inputLines(1).filter { it.isNotBlank() }.map { it.toInt() }.toSet()\n\n    for (i in numberSet) {\n        val need = 2020 - i\n        if (need in numberSet) return i * need\n    }\n    error(\"no solutions found\")\n}\n\nfun main2(): Int {\n    val numberSet = inputLines(1).filter { it.isNotBlank() }.map { it.toInt() }.toSet()\n\n    for (i in numberSet) {\n        for (j in numberSet) {\n            val need = 2020 - i - j\n            if (need in numberSet) return i * j * need\n        }\n    }\n    error(\"no solutions found\")\n}\n```"},{"id":6,"title":"Advent of code, Day 2","desc":"Probably done during english class","tags":["algorithm","aoc","regex"],"url":"advent-of-code-day-2","date":"2020-12-02","content":"It's day 2, and there's another pair of challenges!\n\n\u003e Your flight departs in a few days from the coastal airport; the easiest way down to the coast from here is via toboggan.\n\nAh, of course. Who would have thought.\n\n\u003e Their password database seems to be a little corrupted: some of the passwords wouldn't have been allowed by the Official Toboggan Corporate Policy that was in effect when they were chosen.\n\nI guess this is one of the companies that require password changes often. Hate those guys.\n\n\u003e To try to debug the problem, they have created a list (your puzzle input) of passwords (according to the corrupted database) and the corporate policy when that password was set.\n\u003e For example, suppose you have the following list:\n\u003e ```\n\u003e 1-3 a: abcde\n\u003e 1-3 b: cdefg\n\u003e 2-9 c: ccccccccc\n\u003e ```\n\nIt seems as if there's only a single \"corporate policy\" per each password, seperated by a colon.\n\n\u003e Each line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, 1-3 a means that the password must contain a at least 1 time and at most 3 times.\n\u003e \n\u003e In the above example, 2 passwords are valid. The middle password, cdefg, is not; it contains no instances of b, but needs at least 1. The first and third passwords are valid: they contain one a or nine c, both within the limits of their respective policies.\n\n\u003e How many passwords are valid according to their policies?\n\nAlright, this should be pretty easy.\nRight off the bat I can see that it's a very simple algorithm, which returns a boolean value, and we need to count how many times it's `true`. So let's dive into it!\n\n```kt\nfun main(){\n    val input = \"\"\"\n        1-3 a: abcde\n        1-3 b: cdefg\n        2-9 c: ccccccccc\n    \"\"\"\n\n    val lines = input.split(\"\\n\")       // split by lines\n            .filter(String::isNotBlank) // remove lines that are blank\n```\nWe'll try and use the sample input for testing, as we can verify the outcome.\n\nNow, we need to count the number of lines that have valid passwords. Kotlin (the language I'm using) has a builtin function for counting\n```kt\nfun List\u003cT\u003e.count(predicate: (T) -\u003e Boolean): Int { ... }\n```\nThe function runs the `predicate` over each element, returning the count of ones that return `true`.\n\n```kt\nval answer = lines.count { line -\u003e \n    // checking code ...\n}\n```\n\nIf we go back to the sample input, we can see it follows a simple grammar: `1-2 a: password`.\nWe need to extract certain parts of this input to put into variables\n```\n1-2 a: abcdefgh\n^ ^ ^  \\--------\u003e password\n| | |\n| | letter\n| upper\nlower\n```\nThe fastest way to do this is to split the string at a couple key points - between each important element. We can use a regex to define where we want to split. \n```kt\nval (lower, upper, letter, password) = line.trim().split(Regex(\"(-)|(: )|( )\"))\n```\nFor those who don't know, regex is just a way of selecting text. If we split a string (the input) by a regex, we'll get all the text around it in a list, but not the text actually matched.\n\nThe regex we use here is pretty simple. The `|` OR bars let us match on *any* of the options, as long as one of them matches.\n```regex\n(-)|(: )|( )\n ^   ^^   ^\n |   |   Match a single space\n |  Match a colon, and then a space. This is the text between the letter and the password\nMatch a single hyphen character (split between the numbers)\n```\nHere I use a Kotlin feature called \"destructuring\" to put all the matched elements into separate variables, so the first match goes into the variable `lower`, and the next `upper`, and so one.\n\nNow we need to get how many of the letter `letter` is in the `password`.\nI used another `count` call to count how many letters in the password equalled the `letter` input.\n\n```kt\nval count = password.count { char -\u003e char.toString() == letter }\n```\nI needed to convert the char to a string to compare it to `letter`, as `letter` is a `String`. \n\n*Note, if you're writing this in Java, you need to use `.equals()` to compare strings, instead of `==`*\n\nThen, we can just return if the `count` is within valid range. Here's what it ends up looking like:\n```kt\nval count = lines.count { line -\u003e\n    val (lower, upper, letter, password) = line.trim().split(Regex(\"(-)|(: )|( )\"))\n\n    val count = password.count { char -\u003e char.toString() == letter }\n    \n    return@count count \u003e= lower.toInt() \u0026\u0026 count \u003c= upper.toInt()\n}\n```\nNow, in Kotlin lambdas, we can remove the last return statement (it's automatically inserted). The finally solution for part 1 ends up being.\n```kt\nfun main1(): Int {\n    val lines = inputLines(day = 2)\n            .filter(String::isNotBlank)\n    val count = lines.count { line -\u003e\n        val (lower, upper, letter, password) = line.trim().split(Regex(\"(-)|(: )|( )\"))\n\n        val count = password.count { char -\u003e char.toString() == letter }\n\n        count \u003e= lower.toInt() \u0026\u0026 count \u003c= upper.toInt() // implicit return of this boolean\n    }\n    return count\n}\n```\n\nIt works for the sample input, and it works for my sample input.\n\n## Part 2\n\n\u003e While it appears you validated the passwords correctly, they don't seem to be what the Official Toboggan Corporate Authentication System is expecting.\n\u003e \n\u003e The shopkeeper suddenly realizes that he just accidentally explained the password policy rules from his old job at the sled rental place down the street! The Official Toboggan Corporate Policy actually works a little differently.\n\nOh no! We'll have to copy our code and make some adjustments.\n\n\u003e Each policy actually describes two positions in the password, where 1 means the first character, 2 means the second character, and so on. (Be careful; Toboggan Corporate Policies have no concept of \"index zero\"!) Exactly one of these positions must contain the given letter. Other occurrences of the letter are irrelevant for the purposes of policy enforcement.\n\nSo we need to get the two characters at the points `lower` and `upper` (plus one), see if they equal `letter`, and return true if and only if only one of them are equal. Our truth table would look like this,\n```js\nlower | upper | result\n  1       1       0     // both are equal, there's more then one, so it's a false result\n  1       0       1     // only one is equal, result is true\n  0       1       1     // same as 1, 0\n  0       0       0     // neither match, so it's false\n```\nyou might notice this truth table looks exactly like the `xor` function!\n\nLet's just write this out:\n```kt\nval result = (password[lower - 1] == letter) xor (password[upper - 1] == letter)\n```\n*Remembering that we need to subtract `1`, as the given inputs are based on a 1-index.*\n\nThere's some type issues we need to fix, though. `lower` is a `String` not an `Int`, `letter` is also a `String` not a `Char`. We'll have to convert them, which makes the code look a bit worse.\n```kt\nval result = (password[lower.toInt() - 1] == letter[0]) xor (password[upper.toInt() - 1] == letter[0])\n```\n\nNow we can integrate it into our original counting function.\n```kt\nfun main2(): Int {\n    val lines = inputLines(day = 2)\n            .filter(String::isNotBlank)\n    val count = lines.count { line -\u003e\n        val (lower, upper, letter, password) = line.trim().split(Regex(\"(-)|(: )|( )\"))\n\n        val result = (password[lower.toInt() - 1] == letter[0]) xor (password[upper.toInt() - 1] == letter[0])\n        result // implict return\n    }\n    return count\n}\n```\nAnd that's it, part 2 was pretty easy. There is a couple changes I'll make to change this into more idiomatic Kotlin code, but is mostly irrelevant to the discussion.\n```kt\nfun main2(): Int = inputLines(day = 2)\n        .filter(String::isNotBlank)\n        .count { line -\u003e \n            val (lower, upper, letter, password) = line.trim().split(Regex(\"(-)|(: )|( )\")) \n            (password[lower.toInt() - 1] == letter[0]) xor (password[upper.toInt() - 1] == letter[0]) \n        }\n```\n\nThanks for reading :) I plan on doing these writeups for as long as I have the time."},{"id":2,"title":"An ascii renderer for Git commit trees","desc":"How I wrote a graph renderer to quickly generate commit trees","tags":["unreleased"],"url":"an-ascii-renderer-for-git-commit-trees","date":"2020-08-21","content":"here's some content"},{"id":3,"title":"How to (not) mess up Git","desc":"Git is more then memorizing a few commands and rm -rf * when things go south. Using git properly is important.","tags":["unreleased"],"url":"how-not-to-mess-up-git","date":"2020-08-21","content":"Git is hard! A lot of people I know only know a couple git commands\n```\n$ git add -A .\n$ git commit -m $message\n$ git checkout $branch\n$ git push origin $branch\n```\nand while this works for 90% of all work done on git, it's woefully incompetent at the other 10%: fixing shit when it breaks.\n\n*Now, just to note, git rarely \"breaks\". It's almost always the developer doing something they shoudn't have.*\n\nThis document is going te be a brief summary on some major misconceptions of Git, and then some specific helpful examples that I've needed to use in my time working with Git, or helping other people with them.\n\n## What branches are\n\nBranches are reference to commits. To rephrase that, a branch is just a pointers to a specific commit.\n\nWhen you are working in git, you have this reference called HEAD, which refers to the current working commit.\nYou are always \"on\" a specific commit, which is reflected in the current state of the source code.\nWith git the was you change between commits is the `git checkout` command.\n\nThere's also \"detached head\" state, where you do not live on a branch but instead a specific commit, named by its hash. This is unusual, but worth noting.\n\n**A key point here is that branches don't technically have multiple commits.**\n\nBranches are a single commit, and each commit is some changes plus it's parent(s).\nHere's a quick example:\n```\n a -\u003e b -\u003e c -\u003e d     \u003c--- master\n      \\\n       \\--\u003e e -\u003e f    \u003c--- dev\n```\n`a` is the initial commit. For the purpose of this page, there is only ever one inital commit - while there can be others, merging them isn't really done.\n\nYou might look at this and say \"okay, well, `e` is on the `dev` branch. And, you'd be almost correct.\nWhile dev does encompase `e`, and `e` is \"on dev\", the `e` commit contains exactly zero information about the `dev` branch. \nYou can see that in the next step:\n```\n a -\u003e b -\u003e c -\u003e d -----\u003e g    \u003c--- master\n      \\                 /\\\n       \\--\u003e e -\u003e f -----/\n```\nIn this step, we merged dev into `g` with a merge commit.\n\nNow what branch is `e` on? It's actually on master - but when you commited, you commited to dev!\nDoing a very basic `git log` will just show you `g, f, d, e, c, b, a`, which has no way to tell the difference between commits done on dev and commits done on master.\n\nThis could be an issue if you wanted to have broken code on dev (say commit `e` doesn't work), and now all the sudden it's on master! Some git loggers will properly split the commits so they visually appear on a different history path then the master branch, but they're still 100% on the master branch without the context of dev.\n\n## Some common Git problems\n\n#### I made a commit to the wrong branch!\n```\na -\u003e b -\u003e c   \u003c--- master\n```\nWhoops, you wanted to make the `c` commit on `dev`! This happens to me at least once a week.\nThe fix is easy, but you have to be careful because it involves rewriting history.\n```\n$ git reset --soft HEAD~1\n```\nThis will reset your git repo to `HEAD~1` (meaning the commit before `HEAD`), but because it's a `--soft` reset, it'll keep all the changes in that commit and put them back into staging. Then you can\n```\n$ git checkeout -b dev\n$ git commit\n```\n\n#### I made a commit to the wrong branch and pushed it!\n\nFirst, check with everyone who works on the project to make sure they haven't touched anything yet.\nIf they haven't, you can delete the `c` commit on master with a force push\n```\n$ git push --force origin master\n```\nHowever, this is *not good* and should be avoided if possible. Branch protection rules are offered by GitHub and GitLab, use them if you need to.\n\n#### I made a commit and now there's a merge conflict"},{"id":4,"title":"Some thoughts on optimization","desc":"A short introduction to basic optimization","tags":["compilers","optimization"],"url":"optimization-thoughts","date":"2020-10-21","content":"# Optimization Thoughts\n\nOptimization is a large topic, and only some basics are going to be covered here.\nWe'll be talking about *AST optimizations* today, as it's the most universal form of optimization, independent of backend.\n\nAn AST is an *Abstract Syntax Tree*. This is just how a compiler represents the source code in memory. While we'll being doing a lot of Source Code to Source Code changes for each optimization step, keep in mind that there are not stringy values being manipulated, but a more efficient tree data structure. For the sake of this page, we'll just be working with readable source code.\n\nLet's take a very simple program\n```kt\nfun main() {\n     val a = 7\n     var c = a\n     c += 1\n     val b = a*2 + foo(a) + c\n     if(b \u003c a) error(\"reached illegal state\")\n     while(b \u003e c) c+=c; // do some fun doubling\n     println(a + b + c);\n}\n\nfun foo(i: Int): Int {\n    return if(i \u003c 2) 19 else 18;\n}\n```\nNow, let's optimize this down:\n\n\n### Constant Value Propagation\n\nConstant Value Propagation, or CVP for short on this page, is taking values that are constant (or static) and propagating them across the program. It's effectively inlining variables that have constant, known values. For example,\n```kt\nval a = 7\nval b = a\nval c = a + a\n```\ncan just be\n```kt\nval a = 7\nval b = 7\nval c = 7 + 7\n```\nThis is powerful because it eliminates the overhead of fetching variables like constants. This doesn't seem *that* helpful at first, but it becomes much more useful when combined with other optimizations.\n\nOne shortcoming of CVP is that it requires all values to be known at compile time, and for all values to be stored in **final**, or constant variables, so they do not change.\n\nLet's put our example program through some constant value propagation.\n\n```kt\nfun main() {\n     val a = 7 // this is able to be propagated easily\n     var c = 7 // this is not, as it is mutable (it might change). However, we still inline the 7 from 'a'\n     c += 1\n     val b = 7*2 + foo(7) + c // here we inline the value for 'a'\n     if(b \u003c 7) error(\"reached illegal state\") // everywhere we use 'a' we can replace it with 7\n     while(b \u003e c) c+=c; \n     println(7 + b + c);\n}\n```\n\n### Expression Folding\n\nExpression Folding is pretty simple: pure operations, like arithmetics on pure expressions, can be done at compile time. \nPurity in this context means it doesn't matter if it's actually evaluated at runtime; \n`print(4)` is *impure*, because if you removed it, the program would work differently. \nA *pure* expression can be removed without affecting the program, \n`7 + 8` does not need to be computed at runtime if the program does not use the resulting sum. \nThere's also no need to do `2+2` at runtime when the compiler can just insert `4`, because addition is pure.\nGiven this, we can somewhat reduce the amount of computation we'll do at compile time. In each of theses steps, we'll be continuing on from the function before it, so the input to this optimization step is the outputted function above from Constant Value Propagation.\n\n```kt\nfun main() {\n     val a = 7 \n     var c = 7 \n     c += 1\n     val b = 14 + foo(7) + c  // '7*2' can be changed to '14'\n     if(b \u003c 7) error(\"reached illegal state\")\n     while(b \u003e c) c+=c; \n     println(7 + b + c);\n}\n```\nThis is again, something that isn't very helpful without some other optimizations, which we'll get to below.\n\n### Inlining of functions\n\nWe can inline short functions into the original source code. This can sometimes increase execution speed for a couple reasons: The basic improvement is that we don't need to store the arguments, call, return, and get back the result. This is generally a smaller increase in speed, and is pretty much only important on short functions like `abs` or `max`, where the call overhead is comparable to the actual functionality.\n\nThe more important thing is that it brings more context into the caller function for the compiler to work with. Inlining lets the compiler optimize the callee in the context of the caller, instead of optimizing them separately. \n\nLets inline `foo` into our original function.\n```kt\nfun main() {\n     val a = 7 \n     var c = 7 \n     c += 1\n     val b = 14 + block@ {\n         val i = 7\n         return@block if(i \u003c 2) 19 else 18\n     }() + c\n     if(b \u003c 7) error(\"reached illegal state\")\n     while(b \u003e c) c+=c; \n     println(7 + b + c);\n}\n```\nThis is getting into some more complex Kotlin syntax, but you can think of it like a block (several statements) being used as an expression. The `block@` allows it to return the value locally. As an example,\n```kt\nblock@ { return@block 1 + 20 } + 300\n```\nwould evaluate to `321`\n\nYou can see how we set `i` to the value we passed in for `i` in the original function, `7`.\n\nNow, we can optimize this further with expression folding and constant value propagation. We'll look at just the block for a second.\n```kt\nblock@ {\n    val i = 7\n    return@block if(7 \u003c 2) 19 else 18\n}()\n```\n\n `if(7 \u003c 2)` will clearly fold down to `true`, so we can simplify just down to `19`.\n ```kt\n block@ {\n     val i = 7\n     return@block 19\n }()\n ```\n Because this is kotlin, we can optimize `block@ { return@block 19 }` down to `19`. This gives us, back to our original function.\n ```kt\nfun main() {\n     val a = 7 \n     var c = 7 \n     c += 1\n     val b = 14 + 19 + c // note the 19 here\n     if(b \u003c 7) error(\"reached illegal state\")\n     while(b \u003e c) c+=c; \n     println(7 + b + c);\n}\n```\n\nAnd we can fold some more! \n```kt\nfun main() {\n    val a = 7 \n    var c = 7\n    c += 1\n    val b = 23 + c // added 14 and 19 together\n    if(b \u003c 7) error(\"reached illegal state\")\n    while(b \u003e c) c+=c; \n    println(7 + b + c);\n}\n```\n\nNow, this is great and all, but it isn't perfect. You or me could optimize this better, so we're going to need a couple more tools. \n\n### Dead Code Elimination\n\nDead Code Elimination, or DCE, is removing code that does nothing. This is a pretty simple reducement of the code\n- If a variable is not used, it can be reduced to the expression it's set to\n```kt\nval a = 7 + b// can turn to\n7 + b // just sitting there\n```\n- If an expression is not used, and it is pure, it can be deleted\n```kt\n7 // would be allowed to deleted\n```\n- If an expression is not used, and the outer layer is pure, the outer layer can be deleted\n```kt\nfoo() + bar() // if this exists, and is not used, it can be optimized to\nfoo(); bar() // with no add\n```\n- If some code is unreachable, it can be deleted. This one we won't touch on today as it's more language-specific\n```kt\nreturn 7\nprint(\"hi!\") // this line can be deleted as it will never be reached\n```\n\nWith these rules, we can delete the `a` variable from our program, and it's value `7` as it's pure.\n```kt\nfun main() {\n    // no more a lol\n    var c = 7 \n    c += 1\n    val b = 23 + c\n    if(b \u003c 7) error(\"reached illegal state\")\n    while(b \u003e c) c+=c; \n    println(7 + b + c);\n}\n```\n\nNow, this is pretty nice. However, it's not *that* good. It could be much better. And to do that, we're going to need some better tools\n\n### Static Single Assignment Form\n\nAlso known as SSA, this one is rather hard to implement in compilers. However, we'll give it a go.\n\nSSA is the idea \"what if, every variable was final, and we just made a new variable every single time we assigned it?\"\n\nFor example, a trivial program like\n```kt\nvar foo = 7\nfoo += foo*foo\n```\nmight look hard to optimize logically. If we use SSA, though, we get\n```kt\nval foo_0 = 7\nval foo_1 = foo_0 + foo_0 * foo_0\n```\nwhich can be optimized down to a perfect constant, `val foo_1 = 56`, trivially with the above methods. \n\nLet's run our program through SSA.\n```kt\nfun main() {\n    val c_0 = 7\n    c_1 = c_0 + 1\n    val b = 23 + c_1\n    if(b \u003c 7) error(\"reached illegal state\")\n    while(b \u003e c) c+=c; // wait a minute, what do we do here?\n    println(7 + b + c);\n}\n```\nThe answer is that we make a very fancy control flow graph, which recurs on itself, and has a finite amount of c_n variables.\n\nHowever, that is hard! We're going to skip that for now, and introduce a `c_mut` variable for when we need to do that\n```kt\nfun main() {\n    val c_0 = 7\n    val c_1 = c_0 + 1\n    val b = 23 + c_1\n    if(b \u003c 7) error(\"reached illegal state\")\n    var c_mut = c_1\n    while(b \u003e c_mut) c_mut+=c_mut\n    println(7 + b + c_mut);\n}\n```\n\nNow, you can see here it's trivial to evaluate large amounts of this code\n```kt\nfun main() {\n    val c_0 = 7\n    val c_1 = 7 + 1 // c_0 can be rolled into here, so we should really do\n    val c_1 = 8\n    val b = 23 + c_1 // we can also evaluate this simply, and we should actually just do\n    val b = 31 // 2^5-1, nice\n    if(31 \u003c 7) error(\"reached illegal state\") // DCE can delete this statement as it'll never run, as well as the 'if' statement\n    var c_mut = c_1; // we'll wait on optimizing this for a bit\n    while(31 \u003e c_mut) c_mut+=c_mut\n    println(7 + 31 + c_mut); // inlining of b, should really be\n    println(38 + c_mut) // evaluating the addition\n}\n```\nThat was a big mess of duplicate lines, so let's rewrite that\n```kt\nfun main() {\n    val c_0 = 7\n    val c_1 = 8\n    val b = 31\n    var c_mut = c_1; // we'll wait on optimizing this for a bit\n    while(31 \u003e c_mut) c_mut+=c_mut\n    println(38 + c_mut) // evaluating the addition\n}\n```\nLet's run DCE real quick, as we can delete `c_0`, `c_1`, and `b`.\n```kt\nfun main() {\n    var c_mut = 8; // we'll wait on optimizing this for a bit\n    while(31 \u003e c_mut) c_mut+=c_mut\n    println(38 + c_mut)\n}\n```\n\nNow, this is pretty damn good, what we've done already. \nHowever, because I added this at the beginning, I feel obligated to finish it off :p\n\n### How (not really) to do loops in SSA\n\nLet's make an assumption that normal compilers are unable to make: that the loop will terminate within 5 iterations.\nThis is the only way to solve this without a nice, recursive graph, which is hard to represent in a textual format.\nThis is *not* how this is done in actual compilers.\n\nSo, let's think about how we can remove this loop. We need to remember how while loops actually flow.\n```\n               /----------false-------\\       \nstart -\u003e conditional ---true--\u003e body-\u003e \\---\u003e rest of the program\n            /\\                  /\n             \\-----------------/\n```\nIf we want to remove the recursive structure here, we could do it manually just by repeating the conditional. Here's a loop that runs max 2 iterations\n```\n               /-------false------------------------------------------------\\/\nstart -\u003e conditional --true--\u003e body -\u003e conditional --true--\u003e body -------\u003e rest of the program\n                                            \\--------false------------------/\\\n```\nWe could model this with an `if` statement,\n```kt\nif(cond) {\n    body\n    if(cond) {\n        body\n    }\n}\n```\nKnowing this, we can change our original program (*again, you need to remember that this only works when we have a small upper iteration limit*)\n```kt\nfun main() {\n    val c_10 = 8;\n    if(c_10 \u003c 31) {\n        val c_11 = c_10 + c_10\n        if(c_11 \u003c 31) {\n            val c_12 = c_11 + c_12\n            if(c_12 \u003c 31) {\n                val c_13 = c_12 + c_12\n                if(c_13 \u003c 31) {\n                    val c_14 = c_13 + c_13\n                    // at this point, c_14 is \u003c31 (as per our assumption)\n                }\n            }\n        }\n    }\n    // we still have an issue here, what variable do we print here?\n    println(38 + c_???)\n}\n```\nThe answer to the `c_???` question is: there's not a great way to figure this out. Again, normal ~~people~~ compilers would use proper SSA and not have this problem. We'll just.. ignore it for now. The answer will be obvious after some - you guessed it! - expression folding and variable inlining.\n```kt\nfun main() {\n    val c_10 = 8;\n    if(/*c_10 \u003c 31*/ true) {\n        //val c_11 = 8 + 8\n        val c_11 = 16\n        if(/*c_11 \u003c 31*/ true) {\n            // val c_12 = 16 + 16\n            val c_12 = 32\n            if(/*c_12 \u003c 31*/ false) {\n                /*val c_13 = c_12 + c_12 \n                if(c_13 \u003c 31) {          // all of this can be deleted as the 'if' statement will evaluate to false, via DCE\n                    val c_14 = c_13 + c_13\n                }*/\n            }\n        }\n    }\n    println(38 + c_???)\n}\n```\nWith SSA, the lines between scopes are blurred\n```kt\nfun main() {\n    val c_10 = 8\n    val c_11 = 16\n    val c_12 = 32\n    println(38 + c_???)\n}\n```\nI guess we can assume our `c_???` to be `c_12`, as it's the last version of `c` ever set (remember that these are still just `c` in the original function), which gives us\n```kt\nfun main() {\n    val c_10 = 8\n    val c_11 = 16\n    val c_12 = 32\n    println(38 + 32)\n}\n```\n...DCE\n```kt\nfun main() {\n    println(38 + 32)\n}\n```\n...folding\n```kt\nfun main() {\n    println(70)\n}\n```\nWoo! We've perfectly optimized this program, in a logical process. For reference, here's the original function.\n```kt\nfun main() {\n     val a = 7\n     var c = a\n     c += 1\n     val b = a*2 + foo(a) + c\n     if(b \u003c a) error(\"reached illegal state\")\n     while(b \u003e c) c+=c; // do some fun doubling\n     println(a + b + c);\n}\n\nfun foo(i: Int): Int {\n    return if(i \u003c 2) 19 else 18;\n}\n```"}]},"__N_SSG":true},"page":"/blog","query":{},"buildId":"PeHsZeCWahKZESDnfWMWz","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-ddcc847e43635f820aed.js"></script><script src="/_next/static/chunks/main-5111d87fab9b5370cc9a.js" async=""></script><script src="/_next/static/chunks/webpack-488dc228921f1fdbc0e7.js" async=""></script><script src="/_next/static/chunks/framework.1b5fae6dde8a26be77ac.js" async=""></script><script src="/_next/static/chunks/99f422a92ff7083adb8a7d840734144fa7589f68.385dc8404ef76b6a4b4e.js" async=""></script><script src="/_next/static/chunks/f6078781a05fe1bcb0902d23dbbb2662c8d200b3.93fe777673a5651520d9.js" async=""></script><script src="/_next/static/chunks/pages/_app-93e30f94c05dd8c9a648.js" async=""></script><script src="/_next/static/chunks/1a2af845c0b0daf3d71ab5908136823678b656af.a06c409320be9f87330b.js" async=""></script><script src="/_next/static/chunks/pages/blog-9544ab5f384daa1dc7a6.js" async=""></script><script src="/_next/static/PeHsZeCWahKZESDnfWMWz/_buildManifest.js" async=""></script><script src="/_next/static/PeHsZeCWahKZESDnfWMWz/_ssgManifest.js" async=""></script></body></html>